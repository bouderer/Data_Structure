\centering
# __中山大学计算机学院本科生实验报告__
### （__2025学年第1学期）__
\raggedright 
#### __课程名称：数据结构与算法实验　　　任课教师：张子臻__
| | | | |
|:---:|:---:|:---:|:---:|
|年级|2024级|专业（方向）|计算机科学与技术（人工智能与大数据）|
|学号|242325157|姓名|梁玮麟|
|电话|18620062182|Email|3371676041@qq.com|
|开始日期|2025.10.11|结束日期|2025.10.17|  
  

## __第一题__

### 1、实验题目

#### z5-方程求解

##### 题目描述

已知函数 `y = e^x+ln(x)-1`，实现函数

```cpp
#include "solve.h"
long double solve(long double `y`)
{
// here
}
```

对于传入的`y`，返回x值
要求f(x)与`y`的误差小于``1e-6``，其中`0 < y < 1e10`

### 2、实验目的

求解方程的解，并掌握二分思想，学会给答案预设一个大致区域，然后用二分思想进行搜索。

### 3、算法设计

#### 设计思路如下：

1. 使用**二分查找**的思想来求解。这也是常见的用来逼近答案的方法。
2. 首先需要找到答案的上下限。因为`y`有范围，不难得出`x`的**下界**可以是`0.5`。至于**上界**，可以用一个循环去判断当前上界`top`对应的函数值是否比题目给出的`y`值大，如果小于`y`值就不断地乘二，直至大于等于`y`。
3. 进入查找环节。首先初始化`mid=(bottom+top)/2`,并用一个**while**语句进入查找答案的循环，条件设置为`(exp(top)+log(top)-1-y<0)`：比较当前`mid`对应的函数值和`y`的差值的绝对值是否大于等于`1e-6`。如果小于`1e-6`，说明当前答案已经达到了精度，可以直接返回作为答案；否则继续二分：
    1. 判断mid的函数值是否大于`y`：
        - 如果大于`y`，说明答案在[bottom,mid]之间。令top=mid。
        - 如果小于`y`，说明答案在[mid,top]之间。令bottom=mid。
    2. 更新`mid`，`mid=(bottom+top)/2`.
4. 循环结束后，mid就是最佳答案，直接输出即可。

#### 细节注意:

- 为了**避免精度不够以及数据过大**的问题出现，使用  `long double`。
- `long double`对应的**绝对值函数**`fabsl()`在头文件`<cmath>`中。
- 循环中记得**更新mid**的值。
  
#### 具体实现：

```cpp
//z5-方程求解
#include<iostream>
#include<cmath>
#include"solve.h"
using namespace std;
long double solve(long double y){
    long double bottom = 0.5;
    long double top =1;
    while(exp(top)+log(top)-1-y<0){
        top*=2;
    }
    long double mid =(bottom + top)/2;
    while(fabsl(exp(mid)+log(mid)-1-y)>=1e-6){
        if(exp(mid)+log(mid)-1-y>0){
            top =mid;
        }
        else {
            bottom = mid;
        }
        mid = (top+bottom)/2;
    }
    return mid;
}
```

### 4、程序运行与测试

#### 运行结果：

- 标准输入：
  
```c++

```

- 实际输出：
  
```c++
AC

```

- 期望输出：
  
```c++
AC

```

### 5、实验总结与心得

- 这一题整体主要考察了二分查找的直接应用，难点在于怎么找到**上界**，以及需要注意**long double类型的绝对值函数**与一般不同的问题。因为输入是`y`，所以区间长度大概是`lny`，而查找算法本身是`log2(n)`(n为长度)，所以复杂度大概为**O(log(logy))**。
  

## __第二题__

### 1、实验题目

#### z5-Binary Search

##### 题目描述

实现二分查找函数，函数接口如下。

```cpp
#include "binSearch.h"
int binSearch(const int s[], const int size, const int target)
{
    // 请将实现代码添加在这里
}
```

size为数组s的实际大小。
假定s非递减有序，如果s中存在值为target的元素，
则返回最后一次出现的位序号，否则返回-1表示不存在。
位序号从0开始计。

##### 调用样例

```cpp
int s[8] = {0,1,1,3,3,3,6,6};
cout << binSearch(s,8,3) << endl; //输出5
cout << binSearch(s,8,4) << endl; //输出-1
```

### 2、实验目的

使用二分查找，查找对应元素的最后一个出现的位置，并通过这个实验掌握面对不同要求时，**mid和bottom,top的具体关系**。

### 3、算法设计

#### 设计思路如下：

-  首先是`top`和`bottom`的选择。因为是在给定长度为`size`的数组中查找，所以直接选择让**bottom=0，top=size-1**就可以。为了实现找到最后出现的索引的功能，我要让**top>=target，bottom< target**，使得最终当`top==bottom`时，我们取`result=top`，这个`result< target && result>=target`，所以这个`result`要么是对应的数，要么不是。而且我们因为取得是`top`而不是`bottom`，所以我们的算法**倾向于取相同元素中最后出现的那个位置**，也就实现了我们的目标。
- 对于`mid`的初始化，因为要让`mid`向上取整而不是整除，我们可以让**mid=(top+bottom+1)/2**，这串式子对于`top+bottom`是奇数或者偶数都适用。
- 平均时间复杂度`O(nlogn)`。

1. 为了不断地二分，使用一个`while`循环语句：当`top>bottom`时进入循环：
    1. 比较`mid`对应的数值`s[mid]`与目标数`target`的大小。如果：
        - **s[mid]> target**, 说明`target`对应的值应该在`bottom`和`mid`之间。我选择让新的**top=mid-1**。**因为，如果top=mid，此时s[top]严格>target，并非s[top]>=target。而top=mid-1，s[mid]则有机会与target取等。**
        - 另一种情况，**s[mid]<=target**，说明`target`对应的值应该在`mid`和`top`之间。我选择让新的**bottom=mid。此时，s[bottom]。严格小于target**。
    2. 重新计算`mid`。**mid=(top+bottom+1)/2**。
2. 循环结束，直接判断`s[top]`和`target`是否相等。如果相等，返回`top`，否则返回`-1`。

#### 细节注意：

- **必须保证s[top]大于等于target，s[bottom]严格小于target**。
- **注意mid的计算方式**！若`top+bottom`为奇数，此时需要向上取整；如果是偶数，则无需取整。`/`是整除，自动向下取整。所以在`/2`前先`+1`。
  
#### 具体实现：

```cpp
//z5-Binary Search
#include "binSearch.h"
int binSearch(const int s[], const int size, const int target) {
    int top = size - 1;
    int bottom = 0;
    int mid;
    mid = (top + bottom + 1) / 2;
    while (top > bottom) {
        if (s[mid] > target) {
            top = mid - 1;
        } else {
            bottom = mid;
        }
        mid = (top + bottom + 1) / 2;
    }
    return s[top] == target ? top : -1;
}
```

### 4、程序运行与测试

#### 运行结果：

- 标准输入：
  
```c++
```

- 实际输出：
  
```c++
y

```

- 期望输出：
  
```c++
y

```

### 5、实验总结与心得

- 这一题主要考察的细节就是两个，一个是让mid向上取整，另一个是让top>=target，bottom< target。通过这两个设计，再加上二分查找，就可以找到对应元素的最大索引。
  
## __第三题__

### 1、实验题目


#### z5-最大值最小化

##### 题目描述

把一个包含n个正整数的序列划分成m个连续的子序列（每个正整数恰好属于一个序列）。设第i个序列的各数之和为`S(i)`，如何让所有`S(i)`的最大值尽量小？
例如序列`1 2 3 2 5 4`，划分成3个序列的最优方案为`1 2 3 | 2 5 | 4`，其中`S(1)=6, S(2)=7, S(3)=4`，最大值为`7`；如果划分成`1 2 | 3 2 | 5 4`，则最大值为`9`，不如刚才的好。
$n≤10^6$，所有数之和不超过$10^9$。

##### 输入描述

可能有多个输入样例。
每个样例第一行输入两个整数n和m，第二行输入n个整数。

##### 输出描述

输出所有子序列划分中子序列和的最大值的最小值。

##### 输入样例

```cpp
6 3
1 2 3 2 5 4
```

##### 输出样例

```cpp
7
```
  
### 2、实验目的

通过完成实验，进一步加深对二分思想的理解，学会将二分思想迁移到查找问题之外。

### 3、算法设计

#### 设计思路如下：

- 为了找到最大值的最小值，我们可以假设有**一个答案集合**，只要在这个集合中找到正确答案就可以。找正确答案的过程可以用**二分查找**，然后对于某个元素，只要**验证能否完成划分即可**。
- 时间复杂度O(nlogn)。

1. 记录各个输入。
2. 答案的最小值是这一串数中的最大值，答案的最大值是这一些数的总和。所以我们要求出这些数的和`sum`，并维护`max`，存储这些数的最大值。让**bottom = max, top = sum，取出第一个数作为可能的答案x=(top+bottom)/2。**
3. 用一个`while(top>bottom)`语句进行二分查找：：
    1. 我用`sum`以及`times`分别表示子序列中的总和以及整个序列中可以画的`|`的次数。**其中times初始化为子序列数-1。**
    2. `for`循环，用`j`遍历序列。如果`j < n && times >= 0`，则继续遍历：
        - 如果`sum`加上`j`指向的数依然小于等于`x`，则可以加上这个数，且``j++``。
        - 如果`sum`加上`j`指向的数之后大于`x`，那么就要在这里画`|`，同时`times--`，让`sum`重置为`0`。
    3. 判断**times是否大于等于零**。如果是，说明这个`x`就是理想情况或者比理想情况大，将这个`x`设置为`top`；否则就是`times`小于零，`|`的使用次数超标，`x`太小了，将`bottom`设置为`x+1`。**(这里bottom<x<=top)**
    4. 更新`x=(top+bottom)/2`。
4. 最后跳出了循环，说明`top==bottom`，此时`top`对应的就是正确答案(**因为top可以和x取等**)。
   
#### 细节注意：

- 需要开`long long`！否则数据范围不够！
- 有多个样例输入，需要使用`while(cin>>n)`判断是否还有输入。
  
#### 具体实现：

```cpp
//z5-最大值最小化
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
typedef long long ll;
int main() {
    ll n, m;
    while(cin>>n) {
        cin >> m;
        vector<ll> num;
        ll sum = 0;
        ll max = -1;
        for (ll i = 0; i < n; i++) {
            ll a;
            cin >> a;
            sum += a;
            num.push_back(a);
            if(a>=max) max=a;
        }
        ll bottom = max, top = sum;
        ll x = (bottom + top) / 2;
        while (bottom < top) {
            // 求得区间最大值
            ll sum = 0;
            ll times = m - 1; // 可以划几根棒子分割
            for (ll j = 0; j < n && times >= 0;) {
                if (sum + num[j] <= x) {
                    sum += num[j];
                    j++;
                } else {
                    sum = 0;
                    times--;
                }
            }
            if (times >= 0) { // 当前x太大
                top = x;
            } else {
                bottom = x + 1;
            }
            x = (bottom + top) / 2;
        }
        cout << top << endl;
    }
    return 0;
}
```

### 4、程序运行与测试

#### 运行结果：

##### 数据点0

- 标准输入：
  
```cpp
6 3
1 2 3 2 5 4
```

- 实际输出：
  
```cpp
7

```

- 期望输出：
  
```cpp
7

```

##### 数据点1

- 标准输入：
  
```cpp
14241 2633
1897 12278 6388 11961 20771 31975 17924 13605 14667 25962 28612 15171 5388 7954 5712 7767 29680 17741 18732 19038 584 16953 15564 2444 27341 14777 22874 26617 31623 10953 9907 32664 4590 15118 14771 16488 4688 24753 1714 2286 28274 24174 15694 8930 32634 17896 4459 30761 14092 29760 5497 5123 27572 15589 2550 17542 17540 13998 17971 28747 2046 24358 7770 29799 21044 2087 27312 7836 30253 17322 5144 6097 3723 16861 18905 21184 363 21878 17568 21231 31629 4679 15049 24545 9909 14867 27098 30861 8016 27553 22864 6927 27995 18446 15007 13470 1153 615 2676 19902 3971 3448 22333 18102 2781 23518 20715 14405 29351 26212 1526 19601 1977 27788 29090 9312 28690 9067 16258 7306 13947 18106 26682 1967 28007 16427 2952 12325 31006 22777 11142 13876 17690 10691 11561 7814 26801 15514 16910 9433 32501 5465 8054 9975 13785 5172 9871 15336 22677 26260 25077 19302 22859 31267 31864 14737 7658 9762 5408 31460 5203 32515 5230 9320 20922 2100 26341 19495 16719 14393 16585 19940 9758 765 20263 18441 29748 24170 31253 25825 17668 30007 7227 17415 27401 31745 21394 6175 26796 23710 20332 19651 20071 11182 16309 18624 17451 7282 18808 8323 16895 26338 9380 19662 15339 21497 18193 14768 17684 25684 16574 16819 28200 17659 11613 26967 25340 1663 24337 28351 2932 19013 9846 427 13220 23073 23522 14246 32564 24102 3562 4225 11273 9405 31016 7935 26657 12533 11580 10706 16063 794 785 22726 24777 20361 18530 16957 19566 6082 17532 27867 6155 22975 31301 6530 25680 18821 19325 27009 14751 18680 24900 13576 21684 4595 32220 9696 9867 18072 7089 27224 2942 23525 32150 5251 32175 4744 5202 31136 18085 29173 23899 9690 29754 31157 7905 14386 5300 32001 9486 15033 32306 23695 25741 19202 9546 4780 9801 9943 18160 17803 8311 28971 27033 21469 8406 17232 31137 4001 11317 24170 1258 6974 14135 4388 22983 7375 23635 9633 3352 15294 13086 27574 11190 7316 11469 13142 6929 20239 6645 19277 27927 25206 15766 22577 11096 5161 4440 6038 23912 19580 7956 25474 20101 24005 5014 2593 22138 14772 28322 19897 10691 4323 29748 8415 29938 4270 17164 29420 18258 13125 13418 8363 4297 22015 26903 23892 14083 2546 10148 10174 1484 21184 28662 8144 32446 18355 26627 20537 19485 19213 1494 16480 23295 19353 6873 25246 24752 17542 9299 12972 20308 28533 1328 6231 32206 23761 3329 25211 1761 26207 28739 28206 9109 12310 5604 20028 1245 11056 24067 1748 28790 20353 17912 12672 9490 32520 3476 7514 18870 18372 16809 16254 27745 30664 20429 1979 21486 14226 1884 28046 10555 7833 11196 18768 15243 30245 31717 19886 25641 7779 21280 13658 19791 18873 18190 30976 8261 599 26349 8572 24269 11791 23 2634 27583 1126 3019 10301 1777 10987 10800 10356 16473 27591 20119 31627 9846 14998 257 8462 13291 31605 22753 18227 16494 16476 5411 4808 30944 28847 30060 9066 8893 3855 14500 10232 11959 4470 25778 5959 24222 32643 15238 24855 643 19218 349 11078 4381 5904 30784 28484 8044 24718 13518 3015 31643 15891 12348 7872 28459 10551 15258 15245 27726 1645 14424 20848 10897 24353 14856 22080 30398 515 30053 2398 14849 32162 8341 25323 31817 10556 10411 824 26097 12244 24688 13950 1184 20870 3171 24784 22382 20248 28670 26189 26184 13265 16443 25498 26773 29070 8023 19088 16153 786 1494 14129 17690 2206 15559 4321 15554 4801 19785 19411 23237 3954 2382 24257 13636 3420 4511 16608 6640 18809 32033 1043 3954 15074 1366 24414 1547 4326 23590 15774 31607 22361 3808 9336 5656 13614 6780 1936 31568 31049 5411 23547 25903 27022 4337 32758 15182 2110 7161 19160 13050 17283 393 22853 14997 17225 12464 27045 13370 18768 27646 23764 17312 22399 9867 12059 13121 4220 12858 32096 13499 1657 9023 27289 118 27729 3295 31111 6279 23763 31607 11936 13012 11357 20416 3661 3705 30894 24401 19285 14443 27381 32358 14745 859 24621 22239 22787 14046 27565 12428 3257 14794 26619 3751 21142 15331 2530 18082 3802 8887 10692 29732 16416 15814 14129 28238 12177 1510 2743 8770 29016 27622 2556 30438 18773 31346 21003 7653 18454 20278 23532 30199 13315 12103 20343 25187 4824 15038 30825 15298 26457 934 4536 15877 30529 3096 23332 6073 11643 28580 11535 32394 27796 15347 32398 27910 25969 15531 4544 28068 17981 16019 14943 5893 21926 3576 29332 7545 20041 13391 12816 7621 3690 14619 15192 1316 28649 27153 21344 14987 23665 28282 5980 27953 29171 10714 25811 11343 19283 12751 2037 11300 16737 23355 9262 23613 14346 8869 2811 13043 19408 29661 29949 21045 29559 5343 20812 27016 27137 14330 7949 31051 29917 31026 1351 23360 23132 19170 7410 13384 7268 5542 8529 13166 19304 3959 31362 16935 1431 3608 22100 2520 30292 22706 17240 29337 27111 15547 571 32569 18802 27163 338 10882 4902 23186 13943 10686 8886 18516 19220 14458 24076 30711 20093 20873 6716 22927 25219 31052 19638 17688 5702 32049 23743 22036 25418 19578 10530 10868 205 20032 5666 2236 344 22711 14260 12643 28309 11699 27627 24440 22368 8299 31156 15500 1056 18557 1987 19403 17752 26163 32717 4204 4217 23557 12792 29516 24315 24927 19600 11221 939 21156 31739 12325 27207 17010 18159 28780 30024 12328 31458 24982 28159 1957 15554 6955 15075 20051 4583 3187 20522 8549 30022 3293 3734 26972 19687 19361 1170 26320 21401 25253 17789 31853 19172 4254 19270 23100 2367 24183 5689 28195 14467 13302 32536 15792 22688 8093 28526 3346 23182 21966 29728 30568 26503 11059 24133 23615 10356 3677 26167 18005 8613 17579 1258 12195 30404 28270 30589 18075 11020 5706 8463 6319 12726 20448 16084 17938 25268 10665 8808 8898 10146 30245 26211 26822 29946 12342 20781 24500 25479 32454 23060 7543 32284 7088 1179 17487 6021 8670 1557 25113 15550 1711 26995 21713 5987 17051 9563 22613 21608 27929 22650 8556 25354 20416 8218 10758 8197 13485 15607 4806 16648 29734 31310 15805 5222 1404 2872 1657 26894 5942 21046 15166 12989 29291 18189 15251 15986 11632 28372 24576 2851 29108 6731 3863 6830 22759 24174 9137 20242 9570 31562 2170 10207 22979 9488 11440 29675 29655 25448 13863 19271 20158 31495 5265 25969 28745 5508 23036 8139 17831 7015 31900 18508 4929 29828 26059 118 7138 8839 29262 19592 17179 27087 18394 8948 12006 31872 9174 4115 11401 23507 1891 16920 23741 25521 25754 4419 27408 13441 12564 22615 21640 28478 432 12621 393 30668 5008 27210 14072 12684 26213 18127 8865 27182 19437 24879 1750 26310 4282 16455 18777 18210 8756 30057 27005 13147 21985 22169 8583 1963 13796 10492 14170 29310 30404 20365 16468 14540 31343 21010 23667 5285 1151 20559 11452 25102 955 13689 2269 3595 5345 16365 14353 31741 8867 12578 12612 21806 18159 14812 9848 30379 20851 30371 24423 29010 5985 4212 10089 20523 28783 21942 21145 6396 1315 24431 7731 15127 21069 5816 28737 24695 1493 11887 14967 21771 6326 25899 1115 30802 19019 9077 24745 27944 24778 18997 20981 31712 21262 17770 25234 23186 16281 14110 29619 20406 21721 20122 2000 25330 3754 8150 3147 4145 27933 3891 26196 12533 2167 9580 18186 4078 9853 24522 2786 23243 13551 20632 10317 26192 19795 9175 29077 30889 9715 23603 11784 3582 5161 23605 20057 19271 986 4025 16451 4962 2113 18851 9583 29282 27118 10702 29080 21291 22030 8005 13293 13116 4844 23222 4023 18635 23992 17699 10299 20247 21896 20187 994 27898 6044 10921 10903 27069 28902 18763 881 9265 18633 10533 13714 32763 10530 20023 4175 15664 1925 30285 16017 28194 13257 23925 18810 32633 4038 9910 11852 1669 29789 15615 2951 18898 26553 16478 10578 14333 2261 21362 24860 16583 21566 23843 10371 17512 9755 4752 17269 3366 7530 23881 24981 1829 17548 29119 10976 10881 8964 10745 32656 19354 7292 30856 28480 17839 16648 1980 11090 13231 29359 22808 30862 11083 1064 30980 25611 11856 13537 6850 16211 17972 11846 12451 10178 32238 26175 21627 7471 11787 2810 5202 27599 20223 23532 30556 27989 17849 5138 20268 25950 24186 18813 10532 32013 27110 26125 29744 8690 12380 7549 11956 19505 12163 1183 12482 28640 22053 11753 26257 7600 12865 28465 3882 5840 17755 13493 21349 22542 29463 1374 18708 24640 15878 7238 13950 13794 18112 15223 10767 28672 16691 7158 14925 18007 21562 7936 526 27831 6002 9363 11496 15787 9033 11056 10218 30812 26455 7392 19081 5555 15090 28021 3037 30910 23548 28178 6158 32341 20480 31213 23049 12285 23421 24660 19831 7692 898 12270 11503 9486 19835 18244 20586 8808 12619 20095 20472 23611 29083 32371 16050 8331 20081 22749 4592 24481 17924 13801 2236 17837 22479 19192 10118 6064 32228 3743 71
```

- 实际输出：
  
```cpp
99594
32756
38857
419321
36677
155142
35290
69490
43835
553618


```

- 期望输出：
  
```c++
99594
32756
38857
419321
36677
155142
35290
69490
43835
553618

```

### 5、实验总结与心得

- 这一题很有趣，需要先找到答案的所有可能情况，然后用二分查找的思路去做。我在一开始想的是，用平均数去近似为最好结果，然后再让每个子序列尽可能按照平均数的分分配方法去分。后面发现并不合理。所以，其实二分查找的思想并不局限在查找，需要我们遇到问题灵活变通。